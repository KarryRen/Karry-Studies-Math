# 线性代数

<center>Karry Ren</center>

> 线性代数是最为有力的高维数据分析工具，是理解一切高维运算的基础。
>
> 从2023 年 8 月开始，整理此笔记，旨在将线性代数中的核心知识理解清楚，掌握其基本应用，进而为以后机器学习、深度学习理论的理解奠定基础。考虑到线性代数的出发点比较简单（基本都是从解线性方程组引申出来），本笔记就不过多涉及背景的内容，重点在于核心点的原理与应用。
>
> ```
> 线性代数整体上涉及到的知识可分为
> 
> 一、行列式 // 直接从行列式出发，理解行列式的计算方式与应用
> 	1. 行列式的直接运算 （两种思路并行，直接算出行列式的值）
> 	2. 抽象矩阵的行列式 （行列式和矩阵联系，发现间接规律辅助运算）
> 
> 二、矩阵 // 再回到矩阵，体会矩阵的各种操作变化
> 
> ```

## 一、行列式

### 第一节 行列式的直接计算

> 行列式的纯计算是最基础的应用，核心思路就是两条：
>
> 1. 其一是直接根据定义，借助行列式性质进行化简得到三角型行列式，秒出结果。
> 2. 其二是进行展开，化繁为简
>
> 实际计算中往往是先进行化简，然后在展开的过程中依靠性质得到尽可能多的三角型行列式，简化计算过程。

#### 1.1 行列式定义与性质

**==行列式的定义==**：行列式是方阵引申出来的一种新的数字运算方式，其[**运算本质**](https://www.zhihu.com/tardis/zm/art/37111386?source_id=1005)也是求解方程组而引申出来的概念。（行列式的概念是从基本的推导不断完善而来，注意==克拉默法则==，记住其表示线性方程组解的方式）

1. 取数相乘（逐行**<u>取到不同列</u>**的数字进行相乘）
2. 冠以符号（根据取的**<u>列的顺序</u>**得到逆序数（按行排好算列的），并判断符号）
3. 全部相加（从把所有的取列方式穷举，如果有 n 列，那就有 n! 种取法）

> 1. 求解次数
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812134151302.png" alt="image-20230812134151302 " style="zoom:67%;" />
>
> 2. 主对角线和负对角线行列式求解，也可以直接用定义来求，进而得到相应公式，负对角线注意符号 $(-1)^{\frac{n(n-1)}{2}}$
>
> 3. 行列式函数的导数 => 每行求导后行列式的值加和 

**==行列式的性质==**：可以看到直接采用行列式的定义计算行列式的值基本上是不可能的（要进行n! 次运算），所以必须采用一些基本运算，将行列式化成三角型行列式进行计算。此时就要用到行列式的性质辅助进行。

1. **交换**

   ```c++
   - 行列式两行（列）交换，行列式的值反号
   - 行列式两行（列） 的对应元素全部相等，行列式为 0 
   ```

2. **倍乘**

   ```c++
   - 行列式的某行（列）元素都乘以 k ，则等于其值乘 k ， 如果每一行都乘以 k 整体就是 k 的 n 次方了
   - 行列式的两行（列）对应元素成比例，其值为 0
   ```

3. **倍加**

   ```c++
   - 在行列式中把某行（列）各元素都乘以 k 再加到另一行（列）的对应元素上，行列式值不变
   ```

4. **拆分**

   ```c++
   - 如果行列式的某一行（或某列）元素皆为两数之和，则其行列式的值等于将该行（列）拆分后的两个行列式值的和。【一定要注意是某一行（列），而不是整个矩阵，如果矩阵中每个元素都可以这么写的话，那就需要递归拆解了】
   ```

> 1. **<u>*行和相等逐列相加，列和相等逐行相加*</u>**，加完后提出公因数然后用 1 消，得到三角。
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812141921769.png" alt="image-20230812141921769" style="zoom:50%;" />
>
> 2. **<u>*爪型行列式*</u>**：用中间的爪消去边上的一个爪，得到三角

#### 1.2 行列式展开定理

**==展开定理==**：除了使用定义计算行列式，还可以使用展开定理进行计算。引入了余子式（划掉某元素所在行和列形成的新的行列式），和代数余子式（余子式加上前面的系数 $(-1)^{i+j}$）。可以通过按行展开，元素乘以代数余子式然后相加的方式求出行列式的值（一般的操作都是边化 0 ，边展开）。

> 1. 因为在此引出了代数余子式的概念，所以很多题目会考察**<u>*代数余子式的计算*</u>**，思路无非以下两点。
>
>    ```c++
>    - 如果代数余子式是同在某行列式一行或一列的情况，那就直接对该行列式这一行或着一列的元素进行替换，从而能够得到：代数余子式的值 = 替换后行列式的值（余子式的话就需要考虑符号）
>    - 如果代数余子式是对角线的情况，就需要考虑伴随矩阵以及特征值等概念了
>    ```
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812153725251.png" alt="image-20230812153725251" style="zoom:60%;" />
>
> 2.  **<u>*么型行列式*</u>**：解决么型的通式通法就是通过展开，展开式中为三角行列式，然后相加求解即可。
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812145424057.png" alt="image-20230812145424057" style="zoom:50%;" />
>
> 3. **<u>*梭型行列式*</u>**：一般来说给到五阶以下的梭形可以通过三种方式求解
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812152235424.png" alt="image-20230812152235424" style="zoom:70%;" />
>
>    ```c++
>    - 直接展开
>    - 通过边化 0，边展开
>    - 使用分块矩阵的方法（四阶比较好用），先把第三行拆分，然后调整得到两个分块矩阵
>    ```
>
>    如果是 n 阶的话，可以通过递推关系   进行求解，这种做法的核心仍然是展开
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812153200061.png" alt="image-20230812153200061" style="zoom:50%;" />

**==分块矩阵的计算定理==**：由展开定理，就可以推出分块矩阵的运算公式。

<img src="/Users/karry/Pictures/NoteImages/image-20230812143204971.png" alt="image-20230812143204971" style="zoom:20%;" />

**==范德蒙德行列式==**：由展开可以得到通解公式，之后遇到类似（因为特征太过于明显，所以直接都能看出来）的只需要通过**<u>*加边法或者化简调整*</u>**得到标准的范德蒙德行列式，然后套公式即可。

<img src="/Users/karry/Pictures/NoteImages/image-20230812154341760.png" alt="image-20230812154341760" style="zoom:60%;" />

> 两种加边思路：
>
> 1.  way 1：这种加边是等价的，那就只需要套公式求出变化后的值即可
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812160752316.png" alt="image-20230812160752316" style="zoom:60%;" />
>
> 2. way 2：这种加边是不等价的，就需要找到和原行列式的对应关系（此处就是多项式系数）
>
>    <img src="/Users/karry/Pictures/NoteImages/image-20230812160857734.png" alt="image-20230812160857734" style="zoom:50%;" />

----

### 第二节 抽象矩阵的行列式

> 行列式可以作为矩阵运算的一种工具，和一些抽象矩阵相联系可以得到相应的计算规律。





-----



## 二、矩阵

### 第一节 矩阵的基本概念

